
require(tidyverse)
require(cowplot)
theme_set(theme_bw())


## The intrinsic growth function (for plotting purposes)
## Input:
## - z: vector of trait values
## - theta: width of function
## - bshape: name of the function (as a string) which was called to
##           calculate b and g, depending on the shape of the intrinsic
##           growth function
## Output:
## - values of the intrinsic growth function at the trait values z
b_intrinsic <- function(z, theta, bshape) {
    if (bshape=="b_Gaussian") b <- exp(-z^2/(2*theta^2))
    if (bshape=="b_quadratic") b <- 1-z^2/theta^2
    if (bshape=="b_quadratic_zeroed") b <- (1-z^2/theta^2)*
                                          ((sign(1-z^2/theta^2)+1)/2)
    if (bshape=="b_rectangular") b <- (sign(theta+z)+1)*(sign(theta-z)+1)/4
    return(b)
}


## Plot species densities through time
## Input:
## - dat: data generated by organize_results, defined in solve_eqs.R
## Output:
## - a ggplot2 plot
plot_density <- function(dat) {
    ggplot(dat) +
        geom_line(aes(x=time, y=n, colour=as.factor(species))) +
        scale_y_continuous(name="population density", limits=c(0, NA)) +
        theme(legend.position="none") %>%
        return
}


## Plot species trait values through time
## Input:
## - dat: data generated by organize_results, defined in solve_eqs.R
## Output:
## - a ggplot2 plot
plot_trait <- function(dat) {
    ggplot(dat) +
        geom_ribbon(aes(x=time, ymin=m-sigma, ymax=m+sigma,
                        fill=as.factor(species)), alpha=0.15) +
        geom_line(aes(x=time, y=m, colour=as.factor(species))) +
        ylab("trait value") +
        theme(legend.position="none") %>%
        return
}


## Make a plot of the trait distributions at some given moment
## Input:
## - dat: data generated by organize_results, defined in solve_eqs.R
## - moment: at which time point should the community state be plotted
## - limits: a vector of three entries (x_low, x_high, y_high) for the plot
##           range limits (note: the lower limit for the y-axis is always
##           equal to 0); set y_high to NA to have it determined automatically
## - res: number of evenly spaced sampling points along the trait axis
## Output:
## - a ggplot2 plot
plot_snapshot <- function(dat, moment=0, limits=c(-1, 1, NA), res=501) {
    S <- dat %>% pull(species) %>% max ## number of species
    traitaxis <- seq(limits[1], limits[2], l=res) ## sampling the trait axis
    snap <- dat %>% filter(time==moment) %>% select(-time) ## time = moment
    traits <- expand.grid(species=1:S, trait=traitaxis) ## data frame with traits
    traits["density"] <- 0 ## add column for population densities
    for (i in 1:S) {
        v <- snap %>% filter(species==i) %>% select(n, m, sigma)
        traits$density[(traits$species==i)] <- v$n * ## trait normally distributed,
            dnorm(traits$trait[(traits$species==i)], v$m, v$sigma) ## times density
    }
    landscape <- tibble(trait=traitaxis, r=0) ## for plotting intrinsic rates
    landscape$r <- b_intrinsic(landscape$trait, dat$theta[1], dat$bshape[1])
    landscape$r[landscape$r<0] <- NA
    ## scale the result so that it will show nicely on the plot
    if (is.na(limits[3])) landscape$r <- landscape$r * max(traits$density)
    if (!is.na(limits[3])) landscape$r <- landscape$r * limits[3] * 0.98
    ggplot(traits) + ## generate plot
        geom_line(aes(x=trait, y=density, colour=as.factor(species))) +
        geom_ribbon(aes(x=trait, ymin=0, ymax=density, fill=as.factor(species)),
                    alpha=0.15) +
        geom_line(data=landscape, aes(x=trait, y=r), linetype="dashed",
                  colour="darkred", alpha=0.5, na.rm=TRUE) +
        scale_x_continuous(name="trait value", limits=c(limits[1], limits[2])) +
        scale_y_continuous(name="density", limits=c(0, limits[3])) +
        theme(legend.position="none") %>%
        return
}


plot_rhokappa <- function(dat, parms) {
    rhokappa(dat, parms) %>% ## plot niche overlap and fitness ratio in time
        gather(quantity, value, c(`Niche overlap`, `Competitive difference`)) %>%
        ggplot() +
        aes(x=time, y=value, colour=quantity) +
        geom_line() +
        theme_bw()
}


## Plot time series of densities, time series of trait values, and
## snapshot of the trait distributions at time = moment
## Input:
## - dat: data generated by organize_results, defined in solve_eqs.R
## - moment: time at which trait distribution should be plotted
## - limits: a vector of three entries (x_low, x_high, y_high) for the
##           plot range limits of the trait distribution plot (note:
##           the lower limit for the y-axis is always equal to 0); set
##           y_high to NA to have it determined automatically
## - res: number of evenly spaced sampling points along the trait axis
##               for the trait distribution plot
## Output:
## - a ggplot2 plot with three panels in one column: abundance time series,
##   trait value time seties, and snapshot of trait distribution
plot_all <- function(dat, parms, moment=0, limits=c(-1, 1, NA), res=501) {
    plot_grid(plot_density(dat), plot_trait(dat), plot_rhokappa(dat,parms),
              plot_snapshot(dat, moment=0, limits, res),
              plot_snapshot(dat, moment=extrk$time, limits, res), ncol=1) %>%
        return
}


## Generate a movie out of snapshots of the dynamics (requires FFmpeg to work)
## Input:
## - dat: data generated by organize_results, defined in solve_eqs.R
## - timeseq: a vector of time points at which snapshots should be taken,
##            strung together into a movie
## - limits: a vector of three entries (x_low, x_high, y_high) for the plot
##           range limits (note: the lower limit for the y-axis is always
##           equal to 0); set y_high to NA to determine it automatically
## - res: number of evenly spaced sampling points along the trait axis
## - out: name (w/ path & extension mp4) where temporary files are stored
##        and the movie will be saved
## Output:
## - a video generated with FFmpeg (make sure it is installed)
make_movie <- function(dat, timeseq=seq(0, tmax, by=tmax/100),
                       xmin=-1, xmax=1, res=501, out="./movie.mp4") {
    S <- dat %>% pull(species) %>% max ## number of species
    ## automatically calculate a common upper limit to the y-axis, based on the
    ## requirement that all species are fully within plot limits at all times
    ymax <- dat %>% mutate(md=n/(sigma*sqrt(2*pi))) %>% filter(md==max(md)) %>%
        pull(md) ## md stands for maximum density
    system(paste0("mkdir -p ", dirname(out))) ## make directory to save results in
    for (t in 1:length(timeseq)) { ## generate snapshots and save them in directory
        ggsave(filename=paste0(dirname(out), sprintf("/snap_%05d", t), ".jpg"),
               plot=plot_snapshot(dat, timeseq[t], c(xmin, xmax, ymax), res),
               width=3, height=3)
    }
    system(paste0("ffmpeg -r 50 -i ", dirname(out), "/snap_%05d.jpg ", ## weave
                  "-filter:v \"setpts=4.0*PTS\" ", out)) ## snapshots into movie
    system(paste0("rm -f ", dirname(out), "/snap_*.jpg")) ## remove jpg files
}

